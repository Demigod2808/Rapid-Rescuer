/*
 * TITLE: robot-sensors-atmega2560
 * DATE: 
 * AUTHOR:
 */ 
#define F_CPU 16000000
#include <stdio.h>
#include <avr/io.h>
#include <util/delay.h>
#include <avr/interrupt.h>
#include "i2c.h"
#include "uart.h"
#include "millis.h"
#include "mcp23017.h"

#define PIN_ML_0    PL3
#define PIN_ML_1	PB5
#define PIN_MR_0	PL5
#define PIN_MR_1	PB6	
unsigned char temp[50];
unsigned char val;
uint8_t lfa;
int value,total=0,div=0,mean,err;
int a[8],b[8];
char err1[50];
int prv_er=0;
int default_motorspeed=80;
int kp=7;
int kd=5;
int motorspeed=0;
volatile unsigned int count = 0;	// Used in ISR of Timer2 to store ms elasped
unsigned int seconds = 0;	

void motor_init(void)
{
	DDRL    |= (1 << PIN_ML_0)  | (1 << PIN_MR_0);  
	DDRB    |=  (1 << PIN_ML_1) | (1 << PIN_MR_1);  
	PORTL   |= (1 << PIN_ML_0)  | (1 << PIN_MR_0);  
	PORTB   |= (1 << PIN_ML_1) | (1 << PIN_MR_1);   
	 
}



void init_timer2(void){
	cli();	// Turn off global interrupts

	//Setup Timer2 to fire every 1ms
	TCCR2B = 0x00;        						// Cut off Clock Source to disbale Timer2 while we set it up
	TCNT2  = 130;         						// Reset Timer Count to 130 out of 255
	TIFR2  &= ~(1 << TOV2);        				// Timer2 INT Flag Reg: Clear Timer Overflow Flag
	TIMSK2 |= (1 << TOIE2);        				// Timer2 INT Reg: Timer2 Overflow Interrupt Enable
	TCCR2A = 0x00;        						// Timer2 Control Reg A: Wave Gen Mode normal
	TCCR2B |= (1 << CS22) | (1 << CS20);        // Timer2 Control Reg B: Timer Prescaler set to 128 and Start Timer2

	sei();	// Turn on global interrupts
}



void timer15_init()
{
	cli(); //disable all interrupts
	
	TCCR1B = 0x00;	//Stop
    TCCR5B = 0x00;	//Stop
	
	TCNT1H = 0xFF;	//Counter higher 8-bit value to which OCR5xH value is compared with
	TCNT1L = 0x00;	//Counter lower 8-bit value to which OCR5xH value is compared with
	
	OCR1AH = 0x00;	//Output compare register high value for Red Led
	OCR1AL = 0xFF;	//Output compare register low value for Red Led
	
	OCR1BH = 0x00;	//Output compare register high value for Blue Led
	OCR1BL = 0xFF;	//Output compare register low value for Blue Led

	OCR1CH = 0x00;	//Output compare register high value for Green Led
	OCR1CL = 0xFF;	//Output compare register low value for Green Led
    
    TCNT5H = 0xFF;	//Counter higher 8-bit value to which OCR5xH value is compared with
	TCNT5L = 0x00;	//Counter lower 8-bit value to which OCR5xH value is compared with
	
	OCR5AH = 0x00;	//Output compare register high value for Red Led
	OCR5AL = 0xFF;	//Output compare register low value for Red Led
	
	OCR5BH = 0x00;	//Output compare register high value for Blue Led
	OCR5BL = 0xFF;	//Output compare register low value for Blue Led

	OCR5CH = 0x00;	//Output compare register high value for Green Led
	OCR5CL = 0xFF;	//Output compare register low value for Green Led
	
	
	//  Clear OC4A, OC4B & OC4C on compare match (set output to low level)
	TCCR5A |= (1 << COM5A1) | (1 << COM5B1) | (1 << COM5C1);
	TCCR5A &= ~((1 << COM5A0) | (1 << COM5B0) | (1 << COM5C0));
    TCCR1A |= (1 << COM1A1) | (1 << COM1B1) | (1 << COM1C1);
	TCCR1A &= ~((1 << COM1A0) | (1 << COM1B0) | (1 << COM1C0));

	// FAST PWM 8-bit Mode
	TCCR5A |= (1 << WGM50);
	TCCR5A &= ~(1 << WGM51);
	TCCR5B |= (1 << WGM52);
    TCCR1A |= (1 << WGM10);
	TCCR1A &= ~(1 << WGM11);
	TCCR1B |= (1 << WGM12);
	
	// Set Prescalar to 64
	TCCR5B |= (1 << CS51) | (1 << CS50);
	TCCR5B &= ~(1 << CS52);
    TCCR1B |= (1 << CS11) | (1 << CS10);
	TCCR1B &= ~(1 << CS12);
	
	sei(); //re-enable interrupts
}
void movel (unsigned int left_speed_1, unsigned int left_speed_0){
	OCR5AL = 255 - (unsigned int)left_speed_0; 	// active low thats why subtracting by 255
    OCR1AL = 255 - (unsigned int)left_speed_1; 	
}
void mover (unsigned int right_speed_1, unsigned int right_speed_0){
	OCR5CL = 255 - (unsigned int)right_speed_0;  // active low thats why subtracting by 255
	OCR1BL = 255 - (unsigned int)right_speed_1;
}
void error()
	{
     total=0;
	 div=0;
	 lfa=mcp23017_readpinsA(0);
     value=(int)lfa;
	 for(int n=7;n>=0;n--)
	 {
      a[n]=(value%2);
	  value/=2;
	//  sprintf(err1,"%d",a[n]);
	//  uart0_puts(err1);
	 }
	//  uart0_puts("\n");
	 for(int i=0;i<8;i++)
	 {
		 b[i]=a[i]*1000*i;
	// 	  sprintf(err1,"   %d   ",b[i]);
	//  uart0_puts(err1);
	 }
	//   uart0_puts("\n");
	 for(int i=0;i<8;i++)
	 {
		 total+=b[i];
		 div+=a[i];
	 }
     mean=total/div;
	 mean=mean-3500;
	 err=mean;
	 //er = (exp(err) - exp(-err))/ (exp(err) + exp(-err));
	 err=err/500;
	//  sprintf(err1,"%d\n",err);
	//  uart0_puts(err1);
	}

void pid(void)
{
error();
motorspeed=kp*err+kd*(err-prv_er);
sprintf(temp,"%d\n",motorspeed);
uart0_puts(temp);
prv_er=err;
movel(default_motorspeed+motorspeed,0);
mover(default_motorspeed-motorspeed,0);
}
ISR(TIMER2_OVF_vect) {
  count++;	// increment after 1 ms               
  
  // increment seconds variable after 1000 ms
//   if(count > 999){
// 	seconds++;    
//     count = 0;          
//   }
    if(count>100)
	{
		seconds++;
		count=0;
	}
  
  TCNT2 = 130;           	// Reset Timer to 130 out of 255
  TIFR2  &= ~(1 << TOV2);	// Timer2 INT Flag Reg: Clear Timer Overflow Flag
};
int main(void) {
	i2c_init();
	uart0_init(UART_BAUD_SELECT(9600, F_CPU));
	uart0_flush();
	mcp23017_init();
	mcp23017_setmodeA(MCP23017_BASEADDRESS,MCP23017_MODEINPUTALL);
	mcp23017_setmodeB(MCP23017_BASEADDRESS,MCP23017_MODEOUTPUTALL);
	mcp23017_writepinsB(MCP23017_BASEADDRESS,MCP23017_PINSTATEOFFALL);
	motor_init();
	timer15_init();
	while(1)
	{
		if(seconds%2==0)
		{
    //  error();
	 pid();
		}
	}
	return 0;	
}
