import cv2
import numpy as np

digit_loc = []
img_arr = []
CELL_SIZE = 40


def readImage(img_file_path):
    img1 = cv2.imread(img_file_path)
    gray = cv2.cvtColor(img1, cv2.COLOR_BGR2GRAY)
    ret, binary_img = cv2.threshold(gray, 100, 255, cv2.THRESH_BINARY)
    return binary_img


img_file_path = 'maze00.jpg'

rows = 10
cols = 10


def maze_iso(img):
    global rows
    global cols
    global digit_loc
    d1 = 0
    for y in range(20, 40 * (rows), 40):
        for x in range(20, 40 * (cols), 40):
            t = 0
            for i in range(x - 16, x + 16, 1):
                t += img[i][y]
            if (t != 8160):
                digit_loc.append((x, y))
                d1 = d1 + 1
    temp = np.zeros([16, 16], dtype=int)
    print(digit_loc)
    for y in range(0, d1):
        temp = img[(digit_loc[y][0] - 16):(digit_loc[y][0] + 16), (digit_loc[y][1] - 16):(digit_loc[y][1] + 16)]
        print(temp.shape)
        temp = cv2.resize(255 - temp, (24, 24))
        temp = np.pad(temp, ((2, 2), (2, 2)), "constant", constant_values=0)
        print(temp.shape)
        img_arr.append(temp)
        str1 = 'temp' + str(y)
        cv2.imshow(str1, temp)
        # print(img_arr)
    return img_arr


bin_img = readImage(img_file_path)
cv2.imshow("mzae1", bin_img)
final = maze_iso(bin_img)

import tensorflow as tf
mnist = tf.keras.datasets.mnist
(x_train, y_train), (
x_test, y_test) = mnist.load_data()

x_train = tf.keras.utils.normalize(x_train, axis=1)
x_test = tf.keras.utils.normalize(x_test, axis=1)
test = tf.keras.utils.normalize(img_arr, axis=1)

model = tf.keras.models.Sequential()
model.add(tf.keras.layers.Flatten())
model.add(
    tf.keras.layers.Dense(128, activation=tf.nn.relu))
# model.add(
#     tf.keras.layers.Dense(128, activation=tf.nn.relu))

model.add(
    tf.keras.layers.Dense(128, activation=tf.nn.relu))
model.add(tf.keras.layers.Dense(10,
                                activation=tf.nn.softmax))

model.compile(optimizer='adam',
              loss='sparse_categorical_crossentropy',

              metrics=['accuracy'])

model.fit(x_train, y_train, epochs=7)

val_loss, val_acc = model.evaluate(x_test, y_test)
print(val_loss)
print(val_acc)

predict = []
for i in range(6):
    test = np.reshape(test, (6, 28, 28, 1))
    predictions = model.predict(test)
    print(np.argmax(predictions[i]))
    predict.append(np.argmax(predictions[i]))

cv2.waitKey(0)
cv2.destroyAllWindows()
