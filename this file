'''
*****************************************************************************************
*
*        		===============================================
*           		Rapid Rescuer (RR) Theme (eYRC 2019-20)
*        		===============================================
*
*  This script is to implement Task 1C of Rapid Rescuer (RR) Theme (eYRC 2019-20).
*
*  This software is made available on an "AS IS WHERE IS BASIS".
*  Licensee/end user indemnifies and will keep e-Yantra indemnified from
*  any and all claim(s) that emanate from the use of the Software or
*  breach of the terms of this agreement.
*
*  e-Yantra - An MHRD project under National Mission on Education using ICT (NMEICT)
*
*****************************************************************************************
'''

# Team ID:			[ Team-ID ]
# Author List:		[ Names of team members worked on this file separated by Comma: Name1, Name2, ... ]
# Filename:			task_1c.py
# Functions:		computeSum
# 					[ Comma separated list of functions in this file ]
# Global variables:	None
# 					[ List of global variables defined in this file ]


# Import necessary modules
import os
import sys
import tensorflow as tf
import cv2
import numpy as np

count = 0


#################################################################


# Function Name:	computeSum
# Inputs: 			img_file_path [ file path of image ]
# 					shortestPath [ list of coordinates of shortest path from initial_point to final_point ]
# Outputs:			digits_list [ list of digits present in the maze image ]
# 					digits_on_path [ list of digits present on the shortest path in the maze image ]
# 					sum_of_digits_on_path [ sum of digits present on the shortest path in the maze image ]
# Purpose: 			the function takes file path of original image and shortest path in the maze image
# 					to return the list of digits present in the image, list of digits present on the shortest
# 					path in the image and sum of digits present on the shortest	path in the image
# Logic:			[ write the logic in short of how this function solves the purpose ]
# Example call: 	digits_list, digits_on_path, sum_of_digits_on_path = computeSum(img_file_path, shortestPath)

def computeSum(img_file_path, shortestPath):
    """
    Purpose:
    ---
    the function takes file path of original image and shortest path as argument and returns list of digits, digits on path and sum of digits on path

    Input Arguments:
    ---
    `img_file_path` :		[ str ]
        file path of image
    `shortestPath` :		[ list ]
        list of coordinates of shortest path from initial_point to final_point

    Returns:
    ---
    `digits_list` :	[ list ]
        list of all digits on image
    `digits_on_path` :	[ list ]
        list of digits adjacent to the path from initial_point to final_point
    `sum_of_digits_on_path` :	[ int ]
        sum of digits on path

    Example call:
    ---
    original_binary_img = readImage(img_file_path)

    """

    #############  Add your Code here   ###############
    digits_list = []
    digits_on_path = []
    sum_of_digits_on_path = 0
    img = readImage(img_file_path)
    digit_img_array, coordinate_of_num = maze_iso(img)
    coor_num_on_path = compare(shortestPath, coordinate_of_num, img)
    for i in range(len(digit_img_array)):
        digits_list.append(digit_recog(digit_img_array[i]))
    for i in range(len(coordinate_of_num)):
        im=img[(coordinate_of_num[i][0] - 16):(coordinate_of_num[i][0] + 16), (coordinate_of_num[i][1] - 16):(coordinate_of_num[i][1] + 16)]
        temp = digit_recog(im)
        digits_on_path.append(temp)
        sum_of_digits_on_path += temp

    ###################################################

    return digits_list, digits_on_path, sum_of_digits_on_path


#############	You can add other helper functions here		#############

def search(list, val):
    temp = -1
    for i in range(len(list)):
        if (list[i] == val):
            temp = i
    return temp


# def check_boundary(img,num_on_path,path):
# 	for i in range(len(num_on_path)):
# 		if


def compare(path, num, img):
    path1 = []
    path2 = []
    num_on_path = []
    for i in range(len(path)):
        if (path[i][0] + 40) < 400:
            path1.append(path[i][0] + 40)
        if (path[i][0] - 40) > 0:
            path2.append(path[i][0] - 40)
    for i in range(len(num)):
        temp1 = search(path1, num[i])
        if (temp1 != -1):
            num_on_path.append(temp1)
        else:
            temp2 = search(path2, num[i])
            if (temp2 != -1):
                num_on_path.append(temp2)
    return num_on_path


def readImage(img_file_path):
    img1 = cv2.imread(img_file_path)
    gray = cv2.cvtColor(img1, cv2.COLOR_BGR2GRAY)
    ret, binary_img = cv2.threshold(gray, 100, 255, cv2.THRESH_BINARY)
    return binary_img


def maze_iso(img):
    digit_loc=[]
    rows = int(height / task_1a.CELL_SIZE)
    cols = int(width / task_1a.CELL_SIZE)
    d1 = 0
    for y in range(20, 40 * (rows), 40):
        for x in range(20, 40 * (cols), 40):
            t = 0
            for i in range(x - 16, x + 16, 1):
                t += img[i][y]
            if (t != 8160):
                digit_loc.append((x, y))
                d1 = d1 + 1
    temp = np.zeros([16, 16], dtype=int)
    # print(digit_loc)
    for y in range(0, d1):
        temp = img[(digit_loc[y][0] - 16):(digit_loc[y][0] + 16), (digit_loc[y][1] - 16):(digit_loc[y][1] + 16)]
        temp = cv2.resize(255 - temp, (28, 28))
        img_arr.append(temp)
    # str1='temp'+str(y)
    # cv2.imshow(str1,temp)
    return img_arr, digit_loc


def digit_recog(image):
    global count
    if (count == 0):
        mnist = tf.keras.datasets.mnist
        (x_train, y_train), (x_test, y_test) = mnist.load_data()

        x_train = tf.keras.utils.normalize(x_train, axis=1)
        x_test = tf.keras.utils.normalize(x_test, axis=1)
        test = tf.keras.utils.normalize(image, axis=1)

        model = tf.keras.models.Sequential()
        model.add(tf.keras.layers.Flatten())
        model.add(
            tf.keras.layers.Dense(128, activation=tf.nn.relu))
        model.add(tf.keras.layers.Dropout(0.25))

        model.add(
            tf.keras.layers.Dense(128, activation=tf.nn.relu))
        model.add(
            tf.keras.layers.Dense(128, activation=tf.nn.relu))
        model.add(tf.keras.layers.Dropout(0.25))

        model.add(
            tf.keras.layers.Dense(128, activation=tf.nn.relu))
        model.add(tf.keras.layers.Dense(10,
                                        activation=tf.nn.softmax))

        model.compile(optimizer='adam',
                      loss='sparse_categorical_crossentropy',

                      metrics=['accuracy'])

        model.fit(x_train, y_train, epochs=20)

        # val_loss, val_acc = model.evaluate(x_test, y_test)
        # print(val_loss)
        # print(val_acc)
        # model=  tf.keras.models.load_model('num_reader.model')
        predict = []
        count = 1
        test = np.reshape(test, (l, 28, 28, 1))
        predictions = model.predict(test)

    else:
        test = np.reshape(test, (l, 28, 28, 1))
        predictions = model.predict(test)
    return predictions


#########################################################################


# NOTE:	YOU ARE NOT ALLOWED TO MAKE ANY CHANGE TO THIS FUNCTION
#
# Function Name:	main
# Inputs:			None
# Outputs: 			None
# Purpose: 			the function first takes 'maze00.jpg' as input and solves the maze by calling computeSum
# 					function, it then asks the user whether to repeat the same on all maze images
# 					present in 'task_1c_images' folder or not

if __name__ != '__main__':

    curr_dir_path = os.getcwd()

    # Importing task_1a and image_enhancer script
    try:

        task_1a_dir_path = curr_dir_path + '/../../Task 1A/codes'
        sys.path.append(task_1a_dir_path)

        import task_1a
        import image_enhancer

        print("done")

    except Exception as e:

        print('\ntask_1a.py or image_enhancer.pyc file is missing from Task 1A folder !\n')
        exit()

if __name__ == '__main__':

    curr_dir_path = os.getcwd()
    img_dir_path = curr_dir_path + '/../task_1c_images/'  # path to directory of 'task_1c_images'

    file_num = 0
    img_file_path = img_dir_path + 'maze0' + str(file_num) + '.jpg'  # path to 'maze00.jpg' image file

    # Importing task_1a and image_enhancer script
    try:

        task_1a_dir_path = curr_dir_path + '/../../Task 1A/codes'
        sys.path.append(task_1a_dir_path)

        import task_1a
        import image_enhancer

    except Exception as e:

        print('\n[ERROR] task_1a.py or image_enhancer.pyc file is missing from Task 1A folder !\n')
        exit()

    # modify the task_1a.CELL_SIZE to 40 since maze images
    # in task_1c_images folder have cell size of 40 pixels
    task_1a.CELL_SIZE = 40

    print('\n============================================')

    print('\nFor maze0' + str(file_num) + '.jpg')

    try:

        original_binary_img = task_1a.readImage(img_file_path)
        height, width = original_binary_img.shape

    except AttributeError as attr_error:

        print('\n[ERROR] readImage function is not returning binary form of original image in expected format !\n')
        exit()

    no_cells_height = int(height / task_1a.CELL_SIZE)  # number of cells in height of maze image
    no_cells_width = int(width / task_1a.CELL_SIZE)  # number of cells in width of maze image
    initial_point = (0, 0)  # start point coordinates of maze
    final_point = ((no_cells_height - 1), (no_cells_width - 1))  # end point coordinates of maze

    try:

        shortestPath = task_1a.solveMaze(original_binary_img, initial_point, final_point, no_cells_height,
                                         no_cells_width)

        if len(shortestPath) > 2:

            img = image_enhancer.highlightPath(original_binary_img, initial_point, final_point, shortestPath)

        else:

            print('\n[ERROR] shortestPath returned by solveMaze function is not complete !\n')
            exit()

    except TypeError as type_err:

        print('\n[ERROR] solveMaze function is not returning shortest path in maze image in expected format !\n')
        exit()

    print('\nShortest Path = %s \n\nLength of Path = %d' % (shortestPath, len(shortestPath)))

    digits_list, digits_on_path, sum_of_digits_on_path = computeSum(img_file_path, shortestPath)

    print('\nDigits in the image = ', digits_list)
    print('\nDigits on shortest path in the image = ', digits_on_path)
    print('\nSum of digits on shortest path in the image = ', sum_of_digits_on_path)

    print('\n============================================')

    cv2.imshow('canvas0' + str(file_num), img)
    cv2.waitKey(0)
    cv2.destroyAllWindows()

    choice = input('\nWant to run your script on all maze images ? ==>> "y" or "n": ')

    if choice == 'y':

        file_count = len(os.listdir(img_dir_path))

        for file_num in range(file_count):

            img_file_path = img_dir_path + 'maze0' + str(file_num) + '.jpg'  # path to 'maze00.jpg' image file

            print('\n============================================')

            print('\nFor maze0' + str(file_num) + '.jpg')

            try:

                original_binary_img = task_1a.readImage(img_file_path)
                height, width = original_binary_img.shape

            except AttributeError as attr_error:

                print(
                    '\n[ERROR] readImage function is not returning binary form of original image in expected format !\n')
                exit()

            no_cells_height = int(height / task_1a.CELL_SIZE)  # number of cells in height of maze image
            no_cells_width = int(width / task_1a.CELL_SIZE)  # number of cells in width of maze image
            initial_point = (0, 0)  # start point coordinates of maze
            final_point = ((no_cells_height - 1), (no_cells_width - 1))  # end point coordinates of maze

            try:

                shortestPath = task_1a.solveMaze(original_binary_img, initial_point, final_point, no_cells_height,
                                                 no_cells_width)
                print(shortestPath)

                if len(shortestPath) > 2:

                    img = image_enhancer.highlightPath(original_binary_img, initial_point, final_point, shortestPath)

                else:

                    print('\n[ERROR] shortestPath returned by solveMaze function is not complete !\n')
                    exit()

            except TypeError as type_err:

                print(
                    '\n[ERROR] solveMaze function is not returning shortest path in maze image in expected format !\n')

                exit()

            print('\nShortest Path = %s \n\nLength of Path = %d' % (shortestPath, len(shortestPath)))

            digits_list, digits_on_path, sum_of_digits_on_path = computeSum(img_file_path, shortestPath)

            print('\nDigits in the image = ', digits_list)
            print('\nDigits on shortest path in the image = ', digits_on_path)
            print('\nSum of digits on shortest path in the image = ', sum_of_digits_on_path)

            print('\n============================================')

            cv2.imshow('canvas0' + str(file_num), img)
            cv2.waitKey(0)
            cv2.destroyAllWindows()

    else:

        print('')


